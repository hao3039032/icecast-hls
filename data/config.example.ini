[options]
; This is where you set global options, the
; only one right now is the stop-on-source-ending
; flag. By default, if any source ends before
; the others, the program wraps all the other
; streams up and quits. You can set this to false
; to instead run into all sources have closed.
;stop-on-source-ending = false


; Now, tag mapping - by default this tries to map
; vorbis comments in to reasonable ID3 tags. If
; you need a custom tag map, create a section
; named [tagmap.(ID)] - then in your destination
; you can specify you'd like to use that map.
[tagmap.my-custom-map]
;
; In a tag map, each entry has the vorbis comment
; field on the left, and ID3 frame on the right.
artist = TPE1
title = TIT2
; You can specify multiple matches and set priorities.
; If you don't set one, the implied priority is 0 (highest priority).
;
; So example, your Vorbis files may have both a DATE
; and YEAR field. Typically the DATE is more detailed,
; you can say you want to map both into ID3's TDRC, but
; you prefer DATE.
date = TDRC priority=0
year = TDRC priority=1
; In this case, if both are encountered, date will win.
; If you have multiple matches with the same priority,
; you can potentially merge tags - details are below
; in the destination section.


; Next is configuring sources.
;
; Every source needs some kind of ID in
; the section title.
;
; For example, this source has the
; ID "main"

[source.main]
; It's important to note that the order of keys
; matters somewhat. Basically, the config parser
; knows of a few high-level keys like "input" and
; "decoder". When it sees those, it will load a plugin,
; then subsequent keys will be fed to that plugin,
; until it encounters another high-level key.
;
; Available input plugins:
;   stdin - read from stdin
;   file  - read from a file
input = file
; different plugins will have different parameters,
;
; stdin plugin options:
; (none)
;
; file plugin options:
; file = /path/to/some-file
file = /path/to/some/file.ogg

; You can specify what decoder to use.
; available decoder plugins:
;   miniflac - decode FLAC, FLAC-in-Ogg
;decoder = miniflac

; miniflac plugin options
; (none)
; You can optionally apply a filter
; available filter plugins:
;   avfilter - parse an avfilter-compatible string
;   passthrough - no filtering, default
;
; avfilter options:
;   filter-string - give an ffmpeg/avfilter-compatible filter string

filter = avfilter
filter-string = resample=48000



; Next is configuring destinations, which will
; be linked to a source. One source can be used
; with multiple destinations.
[destination.main]
; the single most important option is what source to use
source = main

; you can specify how to handle duplicate tags. Vorbis Comments
; allow things like, specifying multiple ARTIST tags. ID3 kinda/sorta
; does but support is hit-or-miss, I have some options.
; You could just ignore - the first tag listed will win, this is default:
duplicate tags = ignore 
; Alternatively you can merge them into a list by appending NULLs,
; this is what the ID3 spec recommends:
;duplicate tags = null
; Finally you can merge them by appending a semicolon and space, so if your vorbis
; comments were something like
;   ARTIST=First Artist
;   ARTIST=Second Artist
; the merged tag would be "First Artist; Second Artist"
;duplicate tags = semicolon
;
; You can also specify how to handle unknown tags, should you have a tag that
; may not map well into ID3.
; The default is to ignore them
unknown tags = ignore
; An alternative is to map them into TXXX frames. The tag's key will be
; converted to lowercase.
;unknown tags = txxx


; One fun feature is this app can try to handle embedded images. By default,
; if an image is found in your source tags, it's written out to disk and the
; ID3 specifies a link. The way timed ID3 works, you basically have to re-add
; the tags to every segment, so if you include the image that will probably
; blow up your bandwidth.
;
; If you prefer to keep them in-band, set inband images to true. Default is false.
inband images = false
;
; If you defined a custom tag mapping, you can specify it here:
; tagmap = my-custom-map


; You can also have filters applied on the destination,
; so you can have per-destination filtering.
filter = avfilter
filter-string = aresample=out_sample_fmt=s16


; available output plugins:
;   stdout  - write to stdout
;   file    - write to a file
;   folder  - do the full-blown HLS in a folder
output = folder

; stdout plugin options:
; (none)
;
; file plugin options:
;   path = /path/to/some/file
;
; folder plugin options:
;   folder = /path/to/some/directory
;   hls-target-duration = 2 (some integer number of seconds)
;   hls-playlist-length = 900 (max playlist length, in seconds)
folder = /path/to/some-folder
hls-target-duration = 2
hls-playlist-length = 900
;
; next is the encoder plugin to use
; available encoder plugins:
;   exhale  - encodes USAC audio
;   avcodec - encodes audio using ffmpeg's codecs
encoder = avcodec
;
; exhale plugin options:
;   vbr = [0-9]
;   sbr = disable
;   noise-filling = enable

; avcodec plugin options
;   codec - the name of a codec you'd like to use
;   Any other options will be passed directly to
;   the codec, so you can use b=128k,
;   compression_level=5, etc. They will all
;   be specific to the codec.
codec = aac
b = 128k
profile = aac_low

; next is the muxer to use
; available muxer plugins: fmp4
muxer = fmp4

; fmp4 options:
; You can add multiple loudness values,
; and each loudness value can have multiple measurements.
; Some codecs technically require this (USAC/exhale)
;
; You create a loudness with the type of loudness measurement,
; it can be a track or album loudness.
; loudness = track
;
; Then you set options for the loudness
; true-peak = 0.0
; sample-peak = 0.0
; reliability = [0-3] or a corresponding string:
;   0 = unknown
;   1 = unverified
;   2 = ceiling
;   3 = accurate
; measurement-system = [0-5] or a corresponding string
;   0 = unknown
;   1 = ebu-r128 (or just ebur128, r128)
;   2 = itu-r bs.1770-3 (or just bs1770)
;   3 = itu-r bs.1770-3 pre (or just bs1770pre)
;   4 = user
;   5 = expert
;
; Then to add a measurement, set a measurement method definition
; first, since that affects how value is interpreted. You'll
; also need to set the reliability and measurement system values.
; measurement-method = [0-8] or a corresponding string
;   0 = unknown
;   1 = program loudness
;   2 = anchor loudness
;   3 = maximum of the range
;   4 = maximum momentary loudness
;   5 = maximum short-term loudness
;   6 = range
;   7 = sound pressure level
;   8 = room index
; value = (depends on method)
; reliability = (see above)
; measurement-system = (see above)
;
; So a complete example for specifying a true peak of -1.0 dB, with a program
; loudness of -18 LUFS (basically ReplayGain):
;
; loudness = track
; true-peak = -1.0
; reliability = accurate
; measurement-system = ebur128
;
; measurement-method = program loudness
; value = -18.0
; reliability = accurate
; measurement-system = ebur128
